import * as fs from 'fs';
import * as path from 'path';
import { Logger } from '../utils/Logger';

/**
 * Interface for parsed CMake cache dependency information
 */
export interface CMakeDependencyInfo {
    obs_studio_dir?: string;
    qt6_dir?: string;
    qt6_core_dir?: string;
    qt6_widgets_dir?: string;
    obs_frontend_api_dir?: string;
    libobs_dir?: string;
    [key: string]: string | undefined;
}

/**
 * Interface for CMake cache validation result
 */
export interface CacheValidationResult {
    success: boolean;
    dependencies: CMakeDependencyInfo;
    errors: string[];
    warnings: string[];
    cacheFilePath?: string;
}

/**
 * CMakeCacheParser - Parses CMakeCache.txt to extract dependency paths
 * 
 * This class reads and parses CMakeCache.txt files generated by CMake configuration
 * to extract actual resolved dependency paths for OBS Studio, Qt6, and related libraries.
 */
export class CMakeCacheParser {
    private readonly logger = Logger;

    /**
     * Parse CMakeCache.txt from the specified build directory
     * @param buildDir Path to the build directory containing CMakeCache.txt
     * @returns Promise<CacheValidationResult> Parsed dependency information
     */
    public async parseCacheFile(buildDir: string): Promise<CacheValidationResult> {
        const result: CacheValidationResult = {
            success: false,
            dependencies: {},
            errors: [],
            warnings: []
        };

        try {
            const cacheFilePath = path.join(buildDir, 'CMakeCache.txt');
            result.cacheFilePath = cacheFilePath;

            if (!fs.existsSync(cacheFilePath)) {
                result.errors.push(`CMakeCache.txt not found at: ${cacheFilePath}`);
                this.logger.warn(`CMakeCache.txt not found: ${cacheFilePath}`);
                return result;
            }

            const cacheContent = fs.readFileSync(cacheFilePath, 'utf8');
            result.dependencies = this.extractDependencyPaths(cacheContent);
            result.success = true;

            this.logger.info(`Successfully parsed CMakeCache.txt from: ${cacheFilePath}`);
            this.logDependencyInfo(result.dependencies);

        } catch (error) {
            const errorMsg = `Failed to parse CMakeCache.txt: ${error}`;
            result.errors.push(errorMsg);
            this.logger.error(errorMsg, error);
        }

        return result;
    }

    /**
     * Extract dependency paths from CMakeCache.txt content
     * @param cacheContent Content of CMakeCache.txt file
     * @returns CMakeDependencyInfo Extracted dependency paths
     */
    private extractDependencyPaths(cacheContent: string): CMakeDependencyInfo {
        const dependencies: CMakeDependencyInfo = {};
        
        if (!cacheContent || cacheContent.trim() === '') {
            this.logger.warn('CMakeCache.txt content is empty');
            return dependencies;
        }
        
        const lines = cacheContent.split('\n');

        // Define patterns to match various dependency paths
        const patterns = [
            // OBS Studio related paths
            { key: 'obs_studio_dir', patterns: ['OBS_STUDIO_DIR:PATH=', 'libobs_DIR:PATH=', 'OBS_DIR:PATH='] },
            { key: 'libobs_dir', patterns: ['libobs_DIR:PATH=', 'LIBOBS_DIR:PATH='] },
            { key: 'obs_frontend_api_dir', patterns: ['obs-frontend-api_DIR:PATH=', 'OBS_FRONTEND_API_DIR:PATH='] },
            
            // Qt6 related paths
            { key: 'qt6_dir', patterns: ['Qt6_DIR:PATH=', 'QT6_DIR:PATH=', 'CMAKE_PREFIX_PATH:PATH='] },
            { key: 'qt6_core_dir', patterns: ['Qt6Core_DIR:PATH=', 'QT6CORE_DIR:PATH='] },
            { key: 'qt6_widgets_dir', patterns: ['Qt6Widgets_DIR:PATH=', 'QT6WIDGETS_DIR:PATH='] },
        ];

        for (const line of lines) {
            // Skip comments and empty lines
            if (line.startsWith('//') || line.startsWith('#') || line.trim() === '') {
                continue;
            }

            for (const pattern of patterns) {
                for (const patternStr of pattern.patterns) {
                    if (line.includes(patternStr)) {
                        const value = line.split('=')[1]?.trim();
                        if (value && value !== '') {
                            dependencies[pattern.key] = this.normalizePath(value);
                            break;
                        }
                    }
                }
            }

            // Special handling for CMAKE_PREFIX_PATH which might contain Qt6
            if (line.includes('CMAKE_PREFIX_PATH:PATH=') && !dependencies.qt6_dir) {
                const value = line.split('=')[1]?.trim();
                if (value && (value.includes('qt6') || value.includes('Qt6'))) {
                    dependencies.qt6_dir = this.normalizePath(value);
                }
            }
        }

        return dependencies;
    }

    /**
     * Normalize file paths (handle different path separators, resolve relative paths)
     * @param pathStr Raw path string from CMakeCache.txt
     * @returns string Normalized path
     */
    private normalizePath(pathStr: string): string {
        // Remove quotes if present
        let normalizedPath = pathStr.replace(/^["']|["']$/g, '');
        
        // Handle multiple paths separated by semicolons (common in CMAKE_PREFIX_PATH)
        if (normalizedPath.includes(';')) {
            const paths = normalizedPath.split(';');
            // Return the first valid path that exists
            for (const p of paths) {
                const trimmedPath = p.trim();
                if (trimmedPath && fs.existsSync(trimmedPath)) {
                    normalizedPath = trimmedPath;
                    break;
                }
            }
        }

        // Resolve to absolute path
        try {
            normalizedPath = path.resolve(normalizedPath);
        } catch (error) {
            this.logger.warn(`Failed to resolve path: ${normalizedPath}`, error);
        }

        return normalizedPath;
    }

    /**
     * Validate that dependency paths exist on the filesystem
     * @param dependencies Dependency paths to validate
     * @returns Array of warning messages for non-existent paths
     */
    public validateDependencyPaths(dependencies: CMakeDependencyInfo): string[] {
        const warnings: string[] = [];

        try {
            for (const [key, value] of Object.entries(dependencies)) {
                if (value) {
                    try {
                        if (!fs.existsSync(value)) {
                            warnings.push(`Dependency path does not exist: ${key} = ${value}`);
                        } else {
                            // Additional validation: check if it's a directory
                            const stats = fs.statSync(value);
                            if (!stats.isDirectory()) {
                                warnings.push(`Dependency path is not a directory: ${key} = ${value}`);
                            }
                        }
                    } catch (error) {
                        warnings.push(`Cannot access dependency path: ${key} = ${value} (${error})`);
                        this.logger.warn(`Failed to validate path ${value}`, error);
                    }
                }
            }
        } catch (error) {
            this.logger.error('Failed to validate dependency paths', error);
            warnings.push(`Validation failed: ${error}`);
        }

        return warnings;
    }

    /**
     * Compare current configuration with CMake cache dependencies
     * @param currentDeps Current dependency configuration
     * @param cacheDeps Dependencies from CMake cache
     * @returns object Comparison result with differences
     */
    public compareDependencies(
        currentDeps: Record<string, string>, 
        cacheDeps: CMakeDependencyInfo
    ): { differences: Record<string, { current: string; cache: string }>, hasChanges: boolean } {
        const differences: Record<string, { current: string; cache: string }> = {};
        let hasChanges = false;

        // Map cache keys to config keys
        const keyMapping: Record<string, string> = {
            'obs_studio_dir': 'obs',
            'libobs_dir': 'obs',
            'qt6_dir': 'qt6',
            'qt6_core_dir': 'qt6',
            'obs_frontend_api_dir': 'frontend_api'
        };

        for (const [cacheKey, configKey] of Object.entries(keyMapping)) {
            const cacheValue = cacheDeps[cacheKey];
            const currentValue = currentDeps[configKey];

            if (cacheValue && currentValue && cacheValue !== currentValue) {
                differences[configKey] = {
                    current: currentValue,
                    cache: cacheValue
                };
                hasChanges = true;
            }
        }

        return { differences, hasChanges };
    }

    /**
     * Log dependency information for debugging
     * @param dependencies Dependency information to log
     */
    private logDependencyInfo(dependencies: CMakeDependencyInfo): void {
        this.logger.info('Extracted dependency paths from CMakeCache.txt:');
        for (const [key, value] of Object.entries(dependencies)) {
            if (value) {
                this.logger.info(`  ${key}: ${value}`);
            }
        }
    }

    /**
     * Find build directories that might contain CMakeCache.txt
     * @param projectRoot Root directory of the project
     * @returns string[] Array of potential build directory paths
     */
    public findBuildDirectories(projectRoot: string): string[] {
        const buildDirs: string[] = [];
        const candidates = [
            'build',
            'build_macos',
            'build_windows', 
            'build_linux',
            'build_debug',
            'build_release'
        ];

        for (const candidate of candidates) {
            const fullPath = path.join(projectRoot, candidate);
            if (fs.existsSync(fullPath) && fs.statSync(fullPath).isDirectory()) {
                const cacheFile = path.join(fullPath, 'CMakeCache.txt');
                if (fs.existsSync(cacheFile)) {
                    buildDirs.push(fullPath);
                }
            }
        }

        return buildDirs;
    }
}